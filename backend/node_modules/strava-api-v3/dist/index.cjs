"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Strava: () => Strava_api_default,
  types: () => strava_entity_exports
});
module.exports = __toCommonJS(src_exports);

// src/api/subApi/StravaActivity.api.ts
var StravaActivityApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  async createActivity(props) {
    try {
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/activities`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "POST"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * 
  * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
  * @param props 
  * @returns 
  */
  async getActivityById(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}`;
      if (props.include_all_efforts) {
        url = `${url}?include_all_efforts`;
      }
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/activities/${props.id}`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  /**
  * 
  * List Activity Comments (getCommentsByActivityId)
  * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
  * @param props 
  * @returns 
  */
  async getCommentsByActivityId(props) {
    const { id, ...body } = props;
    try {
      let url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}/comments`;
      url = `${url}?page_size=${props.page_size ?? 30}`;
      if (props.after_cursor)
        url = `${url}&after_cursor=${props.after_cursor}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => {
        console.log("resp");
        console.log(resp);
        return resp.json();
      });
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  /**
  * List Activity Kudoers (getKudoersByActivityId)
  * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
  * @param props 
  * @returns 
  */
  async getKudoersByActivityId(props) {
    const { id, ...body } = props;
    try {
      let url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}/kudos`;
      url = `${url}?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  /**
  * 
  * List Activity Laps (getLapsByActivityId)
  * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
  */
  async getLapsByActivityId(props) {
    const { id, ...body } = props;
    try {
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/activities/${props.id}/laps`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  // http get "https://www.strava.com/api/v3/athlete/activities?before=&after=&page=&per_page=" "Authorization: Bearer [[token]]"
  async getZonesByActivityId(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}/zones`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  async updateActivityById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        body: JSON.stringify(props.body),
        method: "PUT"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  // ========================== stream
  /**
   * Get Activity Streams (getActivityStreams)
   * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
   */
  async getActivityStreams(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/activities/${props.id}/streams`;
      url = `${url}?keys=${props.keys.join(",")}&key_by_type=${props.key_by_type ? "true" : "false"}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  //GET
  //https://www.strava.com/activities/12087149535/export_gpx
  // not present inside documentation ...
  async getActivitiesGpxById(id) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/activities/${id}/export_gpx`;
      console.log(`----> ${url}`);
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaActivity_api_default = StravaActivityApi;

// src/api/subApi/StravaAthlete.api.ts
var StravaAthleteApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  // http get "https://www.strava.com/api/v3/athlete/activities?before=&after=&page=&per_page=" "Authorization: Bearer [[token]]"
  async getLoggedInAthleteActivities(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/athlete/activities?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      if (props.before !== void 0)
        url = `${url}&before=${props.before}`;
      if (props.after !== void 0)
        url = `${url}&after=${props.after}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching gettin activities by id:", error);
      throw error;
    }
  }
  /**
   * Get Authenticated Athlete (getLoggedInAthlete)
   * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
   * @returns 
   */
  async getLoggedInAthlete() {
    try {
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/athlete`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * Get Zones (getLoggedInAthleteZones)
  * @returns Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
  */
  async getLoggedInAthleteZones() {
    try {
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/athlete/zones`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * 
  * @param props 
  * Get Athlete Stats (getStats)
  * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
  * @returns 
  */
  async getStats(props) {
    try {
      const response = await fetch(`${this.stravaApi.getBaseUrl()}/athletes/${props.id}/stats`, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * Update Athlete (updateLoggedInAthlete)
  * Update the currently authenticated athlete. Requires profile:write scope.
  * @param props 
  * @returns 
  */
  async updateLoggedInAthlete(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/athlete?weight=${props.weight}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "PUT"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * Returns a list of the clubs whose membership includes the authenticated athlete.
  */
  async getLoggedInAthleteClubs(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/athlete/clubs?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  *  List Athlete Routes (getRoutesByAthleteId)
  * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
  */
  async getRoutesByAthleteId(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/athletes/${props.id}/routes?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaAthlete_api_default = StravaAthleteApi;

// src/api/subApi/StravaClub.api.ts
var StravaClubApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  async getClubActivitiesById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/clubs/${props.id}/activities?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * 
   * @param props 
   * @returns Returns a list of the administrators of a given club.
   */
  async getClubAdminsById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/clubs/${props.id}/admins?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  async getClubById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/clubs/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Returns a list of the athletes who are members of a given club.
   */
  async getClubMembersById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/clubs/${props.id}/members?page=${props.page ?? 1}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaClub_api_default = StravaClubApi;

// src/api/subApi/StravaGear.api.ts
var StravaGearApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  /**
   * gear
   */
  async getGearById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/gear/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaGear_api_default = StravaGearApi;

// src/api/subApi/StravaRoutes.api.ts
var StravaRoutesApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  /**
   * 
  * Export Route GPX (getRouteAsGPX)
  * Returns a GPX file of the route. Requires read_all scope for private routes.
  * @return gpx file ??? 
  */
  async getRouteAsGPX(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/routes/${props.id}/export_gpx`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => {
        return resp.text();
      });
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Export Route TCX (getRouteAsTCX)
   * Returns a TCX file of the route. Requires read_all scope for private routes.
   */
  async getRouteAsTCX(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/routes/${props.id}/export_tcx`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => {
        return resp.text();
      });
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   *  Get Route (getRouteById)
   * Returns a route using its identifier. Requires read_all scope for private routes.
   */
  async getRouteById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/routes/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Get Route Streams (getRouteStreams)
   * Returns the given route's streams. Requires read_all scope for private routes.
   */
  async getRouteStreams(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/routes/${props.id}/streams`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaRoutes_api_default = StravaRoutesApi;

// src/api/subApi/StravaSegment.api.ts
var StravaSegmentApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  /**
   * Explore segments (exploreSegments)
  * Returns the top 10 segments matching a specified query.
   */
  async exploreSegments(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/segments/explore?bounds=${props.bounds}`;
      if (props.activity_type) url = `${url}&activity_type=${props.activity_type}`;
      if (props.min_cat) url = `${url}&min_cat=${props.min_cat}`;
      if (props.max_cat) url = `${url}&max_cat=${props.max_cat}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   *  List Starred Segments (getLoggedInAthleteStarredSegments)
   * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
   */
  async getLoggedInAthleteStarredSegments(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/segments/starred?page=${props?.page ?? 1}&per_page=${props?.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Get Segment (getSegmentById)
   * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
   */
  async getSegmentById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/segments/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Star Segment (starSegment)
   * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
   */
  async starSegment(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/segments/${props.id}/starred?starred=${props.starred ? "true" : "false"}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "PUT"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Get Segment Streams (getSegmentStreams)
   * Returns the given segment's streams. Requires read_all scope for private segments.
   */
  async getSegmentStreams(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/segments/${props.id}/streams`;
      url = `${url}?keys=${props.keys.join(",")}&key_by_type=${props.key_by_type ? "true" : "false"}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaSegment_api_default = StravaSegmentApi;

// src/api/subApi/StravaSegmentEfforts.api.ts
var StravaSegmentEffortsApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  /**
  * List Segment Efforts (getEffortsBySegmentId)
  * Returns a set of the authenticated athlete's segment efforts for a given segment.
  * Requires subscription.
  */
  async getEffortsBySegmentId(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/segment_efforts?segment_id=${props.segment_id}`;
      if (props.start_date_local)
        url = `${url}&start_date_local=${props.start_date_local}`;
      if (props.end_date_local)
        url = `${url}&end_date_local=${props.end_date_local}`;
      if (props.per_page)
        url = `${url}&per_page=${props.per_page ?? 30}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   *  Get Segment Effort (getSegmentEffortById)
   * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
   */
  async getSegmentEffortById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/segment_efforts/${props.id}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
  * Get Segment Effort Streams (getSegmentEffortStreams)
  * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
  */
  async getSegmentEffortStreams(props) {
    try {
      let url = `${this.stravaApi.getBaseUrl()}/segment_efforts/${props.id}/streams`;
      url = `${url}?keys=${props.keys.join(",")}&key_by_type=${props.key_by_type ? "true" : "false"}`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaSegmentEfforts_api_default = StravaSegmentEffortsApi;

// src/api/subApi/StravaUpload.api.ts
var StravaUploadApi = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  /**
   * Upload Activity (createUpload)
   * Uploads a new data file to create an activity from. Requires activity:write scope.
   */
  async createUpload(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/uploads`;
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "POST",
        body: JSON.stringify(props)
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  /**
   * Get Upload (getUploadById)
   * Returns an upload for a given identifier. Requires activity:write scope.
   */
  async getUploadById(props) {
    try {
      const url = `${this.stravaApi.getBaseUrl()}/uploads/${props.uploadId}`;
      console.log(`----> ${url}`);
      const response = await fetch(url, {
        headers: this.stravaApi.getAuthHeader(),
        method: "GET"
      }).then((resp) => resp.json());
      return response;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
};
var StravaUpload_api_default = StravaUploadApi;

// src/api/subApi/StravaAuth0.api.ts
var allAuth = `read,read_all,profile:read_all,profile:write,activity:read,activity:read_all,activity:write`;
var StravaAuth0Api = class {
  constructor(stravaApi) {
    this.stravaApi = stravaApi;
  }
  getAskAuthUrl(authToAsk) {
    const scope = authToAsk === "t_allAuth" ? allAuth : authToAsk;
    return `https://www.strava.com/oauth/authorize?client_id=${process.env.STRAVA_CLIENT_ID}&redirect_uri=http://localhost&response_type=code&scope=${scope}`;
  }
  async getTokenFromAuth(authorizationCode) {
    try {
      const url = `https://www.strava.com/oauth/token?client_id=${process.env.STRAVA_CLIENT_ID}&client_secret=${process.env.STRAVA_CLIENT_SECRET}&code=${authorizationCode}&grant_type=authorization_code`;
      const resp = await fetch(url, { method: "POST" }).then((resp2) => resp2.json());
      console.log("resp : ");
      console.log(resp);
      return resp;
    } catch (error) {
      console.error("Error fetching athlete profile:", error);
      throw error;
    }
  }
  async retrieveAccessTokenWtRefreshToken(refreshToken) {
    try {
      const url = `https://www.strava.com/oauth/token?client_id=${process.env.STRAVA_CLIENT_ID}&client_secret=${process.env.STRAVA_CLIENT_SECRET}&refresh_token=${refreshToken}&grant_type=refresh_token`;
      const resp = await fetch(url, { method: "POST" }).then((resp2) => resp2.json());
      console.log("resp : ");
      console.log(resp);
      return resp;
    } catch (error) {
      console.error("Error fetching retrieveAccessTokenWtRefreshToken", error);
      throw error;
    }
  }
};
var StravaAuth0_api_default = StravaAuth0Api;

// src/api/Strava.api.ts
var StravaApi = class {
  constructor(props) {
    this.baseUrl = "https://www.strava.com/api/v3";
    this.getBaseUrl = () => this.baseUrl;
    this.setBaseUrl = (baseUrl) => this.baseUrl = baseUrl;
    this.getClientId = () => this.clientId;
    this.setClientId = (clientId) => this.clientId = clientId;
    this.getClientSecret = () => this.clientSecret;
    this.setClientSecret = (clientSecret) => this.clientSecret = clientSecret;
    this.getAccessToken = () => this.accessToken;
    this.setAccessToken = (accessToken) => this.accessToken = accessToken;
    this.getRefreshToken = () => this.refreshToken;
    this.setRefreshToken = (refreshToken) => this.refreshToken = refreshToken;
    this.getAuthHeader = () => ({ "Authorization": `Bearer ${this.accessToken}` });
    this.accessToken = props.accessToken;
    this.clientId = props.clientId;
    this.clientSecret = props.clientSecret;
    this.refreshToken = props.refreshToken ?? "";
    this.auth0 = new StravaAuth0_api_default(this);
    this.activity = new StravaActivity_api_default(this);
    this.athlete = new StravaAthlete_api_default(this);
    this.club = new StravaClub_api_default(this);
    this.gear = new StravaGear_api_default(this);
    this.route = new StravaRoutes_api_default(this);
    this.segment = new StravaSegment_api_default(this);
    this.segmentEffort = new StravaSegmentEfforts_api_default(this);
    this.upload = new StravaUpload_api_default(this);
  }
};
var Strava_api_default = StravaApi;

// src/entity/strava.entity.ts
var strava_entity_exports = {};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Strava,
  types
});
//# sourceMappingURL=index.cjs.map